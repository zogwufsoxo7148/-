## 背景信息

4核8G的服务器，堆内存分配4G内存，新生代：老年代=1：2的比例。

我们要导入20个Sheet，每一个Sheet下是60000条数据，总数据大概是1200000条，我们开启10个线程，每一个线程单批次处理量是1000条。也就是说：单个线程处理1000条，10个线程大概同时进行，会同时往MySQL数据库中存储10000条数据。

## 具体分析

在一个 **4核8G** 的服务器上，JVM 堆内存分配为 4G，新生代和老年代按 **1:2** 的比例分配时，处理 120 万条数据的并发任务时，需要特别关注内存消耗、线程上下文切换、数据库连接数以及整体的任务处理效率。10 个线程同时处理 10000 条数据，每个线程处理 1000 条数据。

### 1. **线程数**的配置

#### 1.1 CPU核心数考虑

服务器是 4 核，在高并发情况下，CPU 资源有限，过多的线程可能导致大量的线程上下文切换，反而影响性能。通常，对于 CPU 密集型任务，线程数可以设置为 `核心数 + 1`，但是由于我们的任务主要是 I/O 密集型（数据库插入操作），可以适当提高线程数。

#### 1.2 任务的并发量和资源消耗

每个线程会处理 1000 条数据，数据库插入操作是 I/O 密集型任务，I/O 操作通常不会占用太多的 CPU 时间，但会占用一定的内存和线程调度资源。考虑到任务的性质，你可以配置的线程数应该在 `CPU核心数 * 2` 到 `CPU核心数 * 5` 之间，但同时需要兼顾内存和其他系统资源。

**线程数**：合理的线程数应当配置为 `8 ~ 12`，具体可以根据实际的 CPU 使用情况调整。在 4 核 CPU 上，10 个线程是一个较为合适的配置，可以满足并发需求，不会造成过多的 CPU 争抢和上下文切换。

### 2. **线程池**其他参数的配置

#### 2.1 核心线程数（corePoolSize）

核心线程数是线程池中始终保持活跃的线程数。通常情况下，核心线程数不应超过 `CPU 核心数 * 2`。如果核心线程数过高，可能会占用系统资源，造成线程调度压力；如果过低，则会导致线程频繁创建和销毁，影响性能。

**建议：**

核心线程数可以设置为 `8`，即 CPU 核心数的 `2 倍`，以确保适当的并发度。

#### 2.2 最大线程数（maximumPoolSize）

最大线程数是线程池中能够创建的最大线程数，超过这个数量的任务会被放入任务队列。对于 I/O 密集型任务，通常可以设置为核心线程数的 2 到 3 倍。这里可以设置为 `12` 或 `16`，以确保在高峰时能够处理更多的并发任务。

**建议：**

最大线程数可以设置为 `12 ~ 16`，根据任务的实际执行时间和系统资源调整。

#### 2.3 任务队列（workQueue）

任务队列用于存放等待执行的任务。如果任务队列过大，可能导致任务等待过长，甚至导致内存占用过高；如果队列过小，则会频繁触发拒绝策略。因此需要根据实际任务的大小和处理速度选择合适的队列大小。

**建议：**

采用 有界队列（如 `ArrayBlockingQueue`），队列大小可以设置为 `1000` 左右（即单批次任务量的 `1/10`）。这样可以防止任务过多积压导致内存消耗过高，同时不会过早触发拒绝策略。

#### 2.4 空闲线程存活时间（keepAliveTime）

对于超过 `corePoolSize` 的线程，在空闲时会等待一段时间再销毁。对于 I/O 密集型任务，可以将空闲线程的存活时间设得较长，以避免线程频繁创建和销毁。

**建议：**

**keepAliveTime** 可以设置为 `60 秒`，即线程在空闲 60 秒后自动回收。

#### 2.5 拒绝策略（RejectionPolicy）

当线程池中的线程数已经达到最大值并且任务队列也已满时，新的任务提交将触发拒绝策略。对于这种高并发任务场景，通常建议选择 `CallerRunsPolicy`，让提交任务的线程自己执行任务，避免任务丢失。

**建议：**

- 使用 `CallerRunsPolicy`，避免过多的任务被拒绝。

### 3. **内存**考虑

#### 3.1 数据量与内存消耗

你的 JVM 堆内存为 4G，而你每次处理的数据是 1000 条，假设每条数据大约消耗几 KB 的内存（取决于数据结构），10 个线程同时处理，可能需要额外考虑内存消耗。如果单条数据消耗较多内存，可能会导致内存溢出。因此，确保在批量插入数据库后，及时释放内存，避免内存泄露。

#### 3.2 新生代与老年代比例

新生代和老年代的比例为 `1:2`，这是比较常见的设置，适合大多数情况。如果任务处理过程中存在大量短生命周期的对象（如批量数据处理产生的临时对象），新生代会被频繁 GC。如果频繁发生内存不足，可以适当增大新生代的比例。

### 4. **实际配置示例**

```Java
import java.util.concurrent.*;

public class ThreadPoolConfig {

    public static ExecutorService createThreadPool() {
        // 核心线程数：8
        int corePoolSize = 8;
        
        // 最大线程数：16
        int maximumPoolSize = 16;
        
        // 线程存活时间：60秒
        long keepAliveTime = 60L;
        
        // 有界队列，大小为1000
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(1000);
        
        // 拒绝策略：CallerRunsPolicy
        RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();
        
        return new ThreadPoolExecutor(
            corePoolSize,            // 核心线程数
            maximumPoolSize,         // 最大线程数
            keepAliveTime,           // 线程存活时间
            TimeUnit.SECONDS,        // 时间单位
            workQueue,               // 任务队列
            handler                  // 拒绝策略
        );
    }
}
```

### 5. **总结**

- **线程数**：考虑到你的服务器是 4 核，设置 8-12 个线程较为合适，10 个线程是可以接受的选择。
- **核心**线程数：设置为 `8`，保持较好的并发处理能力。
- **最大**线程数：设置为 `12~16`，确保在高峰任务下也能处理额外的负载。
- **队列大小**：设置为 `1000`，防止队列过长导致内存占用过多。
- **空闲线程存活时间**：设置为 `60秒`，避免频繁创建和销毁线程。
- **拒绝策略**：使用 `CallerRunsPolicy`，保证任务不会被丢弃。

这套配置可以在你的环境下有效地平衡 CPU、内存和 I/O 操作的需求，同时确保高效的批量数据导入处理。

**根据上述分析，同时结合自己业务的情况来看，最终调整：**

1. **线程池**行为分析

​        • **核心**线程数 **8**：这意味着线程池一开始最多会启动 **8 个线程** 来处理任务。也就是说，前 **8 个Sheet** 会被分配给 8 个线程，线程池会让这 8 个线程同时运行，处理这 8 个Sheet。

​        • **队列大小 10**：其余未分配到线程的任务（即另外 12 个Sheet），将会进入任务队列等待。当任务队列中还能够容纳的时候，线程池不会创建新的线程。

​        • **最大**线程数 **10**：当任务队列被填满（10 个任务已在队列中），且仍有新的任务到达时，线程池会创建额外的线程，最多到 **10 个线程**（核心线程数 8 加上 2 个额外的线程）。当所有 10 个线程都在处理任务，且队列已经满时，后续任务将根据拒绝策略被拒绝或处理。

1. **高峰期**线程数计算

在这种配置下，任务的执行流程如下：

​        • 开始时，**8 个核心线程**会立即启动，处理前 **8 个Sheet**。

​        • 剩下的 **12 个Sheet** 中，**10 个** 会被放入队列中。

​        • 当任务队列中积压了 **10 个任务**，此时再到来的 **第19个Sheet** 和 **第20个Sheet** 会促使线程池创建最多 **2 个新的线程**（因为最大线程数是 10），这时线程池中会有 **10 个线程** 同时运行。

因此，在高峰期时：

​        • **10 个线程** 会同时运行，处理10个Sheet。

​        • 其余2个Sheet任务会继续等待队列中线程的空闲，等到有线程空闲后，再被分配执行。