Spring事务有哪些隔离级别

今天，Java已经卷到“屎上雕花”的程度，八股文的准备如果仅仅靠背诵，很容易陷入“背了忘，忘了背”的死循环中。

所以，我们必须：结合具体的代码demo，尝试系统地掌握，才能更好的卷出一条活路。

Spring 事务的隔离级别定义了一个事务与其他事务之间如何隔离，主要目的是避免多个事务并发执行时可能出现的以下问题：

1. **脏读**（**Dirty Read**）：一个事务读取了另一个未提交事务的数据。
2. **不可重复读**（Non-repeatable Read）：一个事务在读取数据后，另一个事务修改了该数据，导致前一个事务在后续读取时发现数据不一致。
3. **幻读**（Phantom Read）：一个事务在读取多行数据后，另一个事务插入或删除了某些行，导致前一个事务在后续读取时发现数据发生了变化。

Spring 提供了五种事务隔离级别，与标准 SQL 事务隔离级别一致：

### 1. **ISOLATION_DEFAULT**

- **描述**：这是 Spring 的默认隔离级别，使用底层数据库的默认隔离级别。通常情况下，数据库的默认隔离级别是 `READ_COMMITTED`。
- **适用场景**：默认情况下，使用此隔离级别即可，除非有特殊需求。

### 2. **ISOLATION_READ_UNCOMMITTED**

- **描述**：允许一个事务读取另一个未提交事务的数据，这会导致脏读、不可重复读和幻读的情况。
- **优点**：性能最好，因为几乎没有隔离。
- **缺点**：数据一致性最差，容易产生数据错误。
- **适用场景**：几乎不推荐使用，除非对数据一致性要求极低且追求最高性能。

### 3. **ISOLATION_READ_COMMITTED**

- **描述**：一个事务只能读取已经提交的数据，避免了脏读问题，但仍然可能出现不可重复读和幻读。
- **优点**：避免了脏读，性能相对较好。
- **缺点**：仍然存在不可重复读和幻读。
- **适用场景**：这是大多数数据库的默认隔离级别，通常情况下是比较合理的选择。

### 4. **ISOLATION_REPEATABLE_READ**

- **描述**：在一个事务中多次读取相同的数据时，读取的结果是一致的，即使在读取期间有其他事务修改了数据。避免了脏读和不可重复读，但仍可能出现幻读。
- **优点**：确保同一事务内多次读取数据一致。
- **缺点**：仍然可能出现幻读，性能较 `READ_COMMITTED` 略差。
- **适用场景**：适合需要防止不可重复读的情况。

### 5. **ISOLATION_SERIALIZABLE**

- **描述**：最高的隔离级别，完全锁定数据，确保一个事务在执行期间，其他事务不能插入、更新或删除数据，避免了脏读、不可重复读和幻读。
- **优点**：提供了最严格的数据一致性保障。
- **缺点**：性能最差，可能导致大量锁竞争，降低并发性能。
- **适用场景**：在数据一致性要求极高且并发量较低的场景下使用。

### 使用示例：

在 Spring 中，可以通过 `@Transactional` 注解来设置事务的隔离级别：

```Java
@Service
public class MyService {

    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void perform() {
        // 业务逻辑
    }
}
```

### 总结：

根据业务需求和性能考虑，选择合适的事务隔离级别可以有效平衡数据一致性和系统性能。`READ_COMMITTED` 和 `REPEATABLE_READ` 是常用的隔离级别，而 `SERIALIZABLE` 适用于对数据一致性要求非常高的场景。

Coding不易，棒棒，加油！